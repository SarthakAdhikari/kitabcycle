#+SETUPFILE: ~/org/conf/org-html-themes/setup/theme-readtheorg-local.setup
#+HTML_HEAD: <style>.listing-number { display: none; } .org-src-name {text-decoration: underline} pre.src{background:#343131;color:white; font-size:1.2rem}</style>
#+OPTIONS: num:nil ^:nil \n:t

* Django Tutorial
:PROPERTIES:
:CODE_ROOT: ../
:END:
Hello, Welcome to the first post.

This is more of a personal note than a tutorial and our goal is to create an
application called "KitabCycle". KitabCycle is a C2C website for booksharing.

The feature specs for the project are listed [[/home/sarthak/Documents/Code/KitabCycle/design_documents/filtered-requirements.org][here]]. Let's start!
** Setting up the environment
   :PROPERTIES:
   :header-args: :dir ../
   :END:

    We are going to use Docker containers for deployment. Docker
    containers are processes that share the same kernel as the host
    operating system but each process is running in its own
    userspace(unlike VM which has its own kernel).  Docker reads
    instruction from a file called =Dockerfile= to build the container
    and the first instruction must always be ~FROM <parent-image>~.
    Further instructions are layers on top of the parent image which
    in turn build up a new image. We will create a new folder called
    ~Dockerfile~ in the root directory(same level as ~manage.py~) and add
    the following:

#+begin_src dockerfile :noweb-ref parent-image
FROM python:3.7-alpine
MAINTAINER Sarthak
#+end_src

This fetches the image pre-built by docker for python3.7 using the alpine distro. Since, we are going to run python inside docker, it is recommended to run python in unbuffered mode. This is because it output logs in real time and ensure that logs are always printed out and don't disappear during a crash(because they were still in the buffer during the crash). So let's do that:

#+begin_src text :tangle (concat (org-entry-get nil "CODE_ROOT" t) "requirements.txt")
Django>=3.1.1,<3.2.0
djangorestframework>=3.12.0,<3.12.4
psycopg2>=2.8.6,<2.9.0
flake8>=3.8.3,<3.9.0
#+end_src

#+begin_src dockerfile :noweb-ref unbuffered
ENV PYTHONUNBUFFERED 1
#+end_src

Our requirements.txt will look like:

Now we copy our ~requirements.txt~ from our app inside our docker container.

#+begin_src dockerfile :noweb-ref requirements
COPY ../requirements.txt ./requirements.txt
#+end_src

For now, ~Dockerfile~ looks like:

#+caption: Dockerfile
#+begin_src dockerfile :noweb yes :tangle (concat (org-entry-get nil "CODE_ROOT" t) "Dockerfile")
<<parent-image>>

<<unbuffered>>

<<requirements>>
#+end_src

We will keep necessary lines to our ~Dockerfile~ as we go further in the project but this will do for now.

** The core
*** Initialization
    :PROPERTIES:
    :header-args: :dir ../
    :END:
  We are going to start by creating a core app.

  #+begin_src shell
  python manage.py startapp core
  #+end_src

  #+RESULTS:

  add that to =settings.py= like such:
  #+begin_src python
  INSTALLED_APPS = [
      'django.contrib.admin',
      'django.contrib.auth',
      'django.contrib.contenttypes',
      'django.contrib.sessions',
      'django.contrib.messages',
      'django.contrib.staticfiles',
      'core',
  ]
  #+end_src

  #+RESULTS:
  : None

With that in place, we are ready to write our very first test.

*** Structure of tests

    Before writing our first test, let's quickly discuss how we are
    going to organize our directory structure for tests in the
    project. We will follow this directory structure in all the future
    apps related to this project.

    #+caption: structure of test directories
    #+begin_example :exports results
     core
     │    | admin.py    |                |
     │    | apps.py     |                |
     │    | __init__.py |                |
     │    | migrations  |                |
     │    | └──         |                |
     │    | tests       |                |
     │    | └──         |                |
     │    |             | test_first.py  |
     │    |             | test_second.py |
     │    |             | test_third.py  |
     │    | views.py    |                |
     │    | models.py   |                |

    #+end_example

    We created a new folder called ~tests~ and all our test files will start
    with a prefix of ~test_~ followed by the name of the test file. We will
    follow this structure for all the future apps we create.

*** Core App
     :PROPERTIES:
     :CORE_TESTS_DIR: ../core/tests/
     :CORE_DIR: ../core/
     :END:
****  Writing our first test

 Since, we are following Test Driven Development(TDD) approach, let us
 understand what it means. At the heard of TDD is the idea of "Test first!".
 First, we write the test. Then we see if it fails, which is likely to happen
 because we have not written any code up until this point. Then, we write the
 code and check if the test passes afterwards. This approach not only allows
 us to ensure that the code is bug-free but also ensures that the tests are
 bug-free. If the tests don't pass before writing the code and passes only
 after writing the code, we can be sure that the test is actually checking
 for what it was originally supposed to check for.


 We are going to implement the Custom user model feature first. But
 before that, we must write a test. Our user model is going to have an
 email field unlike the default django username field. So, let us
 start by testing whether we can successfully register a user using an
 email address. Let's start with the imports:

 #+begin_src python  :noweb-ref test-model-imports
from django.test import TestCase
from django.contrib.auth import get_user_model

from core import models
 #+end_src

 ~django.TestCase~ creates a clean database and runs every test in its
 own transaction. In other words, every test will create its own
 tables which in some cases might cause the tests to run slower.

 #+begin_src python  :noweb-ref test-model-declaration :exports code
class ModelTests (TestCase):
 #+end_src
We import from TestCase and name each of our function starting with ~test_<test_name>~ like below. Let us start with 2 tests:

+ Test 1 :: Check whether we can successfully create a user using an email.
#+begin_src python  :noweb-ref test-create-user-with-email-sucessful :exports code
def test_create_user_with_email_sucessful(self):
    '''Test creating a new user with email is successful.'''
    email = "test@exampl.com"
    password = "test@123user"
    user = get_user_model().objects.create_user(email=email, password=password)
    self.assertEqual(user.email, email)
    self.assertTrue(user.check_password(password))
#+end_src

+ Test 2 :: Check whether the email address we use is normalized.
 #+begin_src python  :noweb-ref test-create-user-with-email-sucessfull :exports code
def test_create_user_with_email_normalized(self):
    '''Test that email of new user is normalized.'''
    email = "test@EXAMPLE.COM"
    password = "test@123user"
    created_user = get_user_model().objects.create_user(email=email,
                                                    password=password)
    self.assertEqual(self.created_user.email, self.email.lower())
#+end_src

Here's what our =tests/test_models.py= looks like right now:
#+caption: core/tests/test_models.py
#+begin_src python  :noweb yes :tangle (concat (org-entry-get nil "CORE_TESTS_DIR" t) "test_models.py")
<<test-model-imports>>

<<test-model-declaration>>
    <<test-create-user-with-email-sucessful>>

    <<test-create-user-with-email-normalized>>
 #+end_src

Remember how we said we first deliberately write a test that fails?
Let's see it in action:

#+begin_src sh :session run-in-root :exports none :results silent
cd "$(git rev-parse --show-toplevel)"
#+end_src

#+begin_src sh  :exports both :session run-in-root :results scalar
python manage.py test
#+end_src

#+RESULTS:
#+begin_example
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
E
======================================================================
ERROR: test_create_user_with_email_sucessful (core.tests.test_models.ModelTests)
Test creating a new user with email is successful.
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/sarthak/Documents/Code/KitabCycle/kitabcycle/core/tests/test_models.py", line 11, in test_create_user_with_email_sucessful
    user = get_user_model().objects.create_user(email=email, password=password)
TypeError: create_user() missing 1 required positional argument: 'username'

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (errors=1)
Destroying test database for alias 'default'...
#+end_example

Good news! Our tests failed. That means we are ready to move on to writing the code to fix it.

**** Custom User Model
